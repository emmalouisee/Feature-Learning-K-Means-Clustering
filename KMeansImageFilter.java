package weka.filters.unsupervised.attribute;


import no.uib.cipr.matrix.*;
import no.uib.cipr.matrix.Matrix;
import weka.core.*;
import weka.core.matrix.Maths;
import weka.filters.SimpleBatchFilter;
import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

/**
 * A filter that can be used to process a collection of images for classification or clustering. It applies
 * spherical k-means to image batches extracted from the first batch of images it receives and uses
 * the resulting k-means centroids to process images into feature vectors suitable for classification or
 * clustering.
 *
 * The first attribute in the input data is required to be a string attribute with the file names of images.
 */
public class KMeansImageFilter extends SimpleBatchFilter {

    /** The seed for the random number generator. */
    protected int m_seed = 0;

    /** The width and height of each extracted image patch in pixels. */
    protected int m_cropSize = 8;

    /** The number of patches to be extracted from each image. */
    protected int m_numPatchesPerImage = 1;

    /** The number of clusters aka filters aka dictionary atoms to use. */
    protected int m_K = 1000;

    /** The stride for the application of the filters (when feature vectors are computed). */
    protected int m_stride = 4;

    /** The height and width of the pool used to reduce the dimensionality of the feature vectors. */
    protected int m_poolSize = 2;

    /** The dictionary matrix, with one column per filter (aka atom). */
    protected Matrix m_D;

    /**
     * The method used to establish the format of the data generated by this filter, as an Instances object.
     *
     * @param data the input dataset, with a string attribute containing the file names of the images
     * @return an Instances object that provides the "header" information for the data generated by this filter
     * (i.e., an Instances object that does not contain any actual instances but does contain a list of attributes).
     */
    public Instances determineOutputFormat(Instances data) {

        if (m_Debug) {
            System.err.println("Determining output format.");
        }
        int imgSize = -1;
        for (int i = 0; i < data.numInstances(); i++) {
            String fileName = data.instance(i).stringValue(0);
            BufferedImage img = null;
            try {
                img = ImageIO.read(new File(fileName));
            } catch (Exception ex) {
                System.err.println("Could not load: " + fileName);
            }
            if (img.getWidth() != img.getHeight()) {
                throw new IllegalArgumentException("Image " + fileName + " is not square.");
            }
            if (imgSize == -1) {
                imgSize = img.getWidth();
            } else if (imgSize != img.getWidth()) {
                throw new IllegalArgumentException("Image " + fileName + " has different size.");
            }
        }
        if (m_Debug) {
            System.err.println("Image size is: " + imgSize);
        }
        if (((imgSize - m_cropSize) % m_stride) != 0) {
            throw new IllegalArgumentException("Image height not compatible with patch size and stride");
        }
        if ((1 + ((imgSize - m_cropSize) / m_stride)) % m_poolSize != 0) {
            throw new IllegalArgumentException("Pool size not compatible with raw features.");
        }

        int nFeatPerFilterAndDimension = (1 + ((imgSize - m_cropSize) / m_stride)) / m_poolSize;
        int numFeatures = nFeatPerFilterAndDimension * nFeatPerFilterAndDimension * m_K;

        ArrayList<Attribute> atts = new ArrayList<>(numFeatures + 1);
        for (int i = 0; i < numFeatures; i++) {
            atts.add(new Attribute("x" + (i + 1)));
        }
        if (data.classIndex() > -1) {
            atts.add((Attribute) data.classAttribute().copy());
        }
        Instances output = new Instances("features", atts, 0);
        output.setClassIndex(output.numAttributes() - 1);
        if (m_Debug) {
            System.err.println("Finished determining output format with " + output.numAttributes() + " attributes.");
        }
        return output;

    }

    /**
     * The method that processes the given dataset and outputs the filtered data.
     *
     * @param data the input data to be filtered, with a string attribute containing the file names of the images
     * @return the filtered data, consisting of feature vectors ready for other machine learning algorithms
     */
    public Instances process(Instances data) throws Exception {

        // We will need a random number generator
        Random rand = new Random(m_seed);

        // Establish number of rows and columns for data matrix X
        int numPatchPixels = m_cropSize * m_cropSize;
        int numPatchValues = numPatchPixels * 3; // Three colour channels
        int numPatches = m_numPatchesPerImage * data.numInstances();

        // Create constant vectors that we will reuse many times to center the values in each patch
        Vector oneOverNumPatchValues = constantVector(1.0 / numPatchValues, numPatchValues);
        Vector allOnesNumPatchValues = constantVector(1.0, numPatchValues);

        // Is this the first batch of data passed through the filter (i.e., the filter bank has not been
        // created yet)?
        if (!isFirstBatchDone()) {

            // Read image patches, normalize patches, and turn them into columns in the matrix X
            Matrix X = new DenseMatrix(numPatchValues, numPatches);
            int colIndex = 0;

            for (int i = 0; i < data.numInstances(); i++) {
                String fileName = data.instance(i).stringValue(0);
                BufferedImage img = null;
                try {
                    img = ImageIO.read(new File(fileName));
                    int xmax = 1 + img.getWidth() - m_cropSize;
                    int ymax = 1 + img.getHeight() - m_cropSize;
                    //foreach num of patches
                    for (int p = 0; p < m_numPatchesPerImage; p++) {

                        BufferedImage patch = img.getSubimage(rand.nextInt(xmax), rand.nextInt(ymax), m_cropSize, m_cropSize);
                        int index = 0;
                        Vector vec = new DenseVector(numPatchValues);
                        for (int j = 0; j < m_cropSize; j++) {
                            for (int k = 0; k < m_cropSize; k++) {
                                int rgb = patch.getRGB(k,j);
                                int r = (rgb >> 16) & 0xFF;
                                int g = (rgb >> 8) & 0xFF;
                                int b = (rgb & 0xFF);
                                vec.set(index, r);
                                vec.set(numPatchPixels + index, g);
                                vec.set(2 * numPatchPixels + index, b);
                                index++;
                            }
                        }
                        Vector centeredVec = vec.add(-vec.dot(oneOverNumPatchValues), allOnesNumPatchValues);
                        double norm = centeredVec.norm(Vector.Norm.Two);
                        Vector normalizedVec = centeredVec.scale(1.0 / Math.sqrt((norm * norm) / vec.size() + 10));
                        for (int r = 0; r < normalizedVec.size(); r++) {
                            X.set(r, colIndex, normalizedVec.get(r));
                        }

                        colIndex++;
                    }
                } catch (IOException e) {
                    System.err.println("File " + fileName + " could not be read");
                }
            }
            if (m_Debug) {
                System.err.println("Calculating mean value for each pixel in X.");
            }
            Vector mean = X.mult(constantVector(1.0 / numPatches, numPatches), new DenseVector(numPatchValues));

            if (m_Debug) {
                System.err.println("Calculating centered version of X and storing it in S.");
            }

            Matrix S = new DenseMatrix(X);
            S = (new DenseMatrix(mean)).transBmultAdd(-1.0, new DenseMatrix(constantVector(1.0, numPatches)), S);

            if (m_Debug) {
                System.err.println("Calculating covariance matrix.");
            }
            Matrix cov = (new UpperSPDDenseMatrix(numPatchValues)).rank1(1.0 / numPatches, S);

            if (m_Debug) {
                System.err.println("Performing eigenvalue decomposition.");
            }
            SymmDenseEVD evd = SymmDenseEVD.factorize(cov);
            double[] evals = evd.getEigenvalues();
            Matrix V = evd.getEigenvectors();
            Matrix E = new UpperSymmDenseMatrix(evals.length);
            for (int i = 0; i < evals.length; i++) {
                E.set(i, i, 1.0 / Math.sqrt(evals[i] + 0.1));

            }
            if (m_Debug) {
                System.err.println("Whitening data.");
            }
            X = V.mult(E, new DenseMatrix(V.numRows(), E.numColumns())).transBmult(V, new UpperSymmDenseMatrix(V.numRows())).
                    mult(X, new DenseMatrix(V.numRows(), X.numColumns()));


            //intialise m_D to an empty matrix
            m_D = new DenseMatrix(numPatchValues, m_K);

            //for each column of D...
            for (int c = 0; c < m_D.numColumns(); c++) {
                //foreach row of D...
                for (int r = 0; r < m_D.numRows(); r++) {
                    //store random value in D at current element
                    m_D.set(r, c, rand.nextGaussian());
                }
            }

            //normalise each column of m_D
            normalizeD();

            //create variable to keep track of the previous sum of squared error
            double prevSSE = 0;

            //loop until SSE converges
            while (true) {
                //generate S matrix by multipling the transpose of D with X
                S = new DenseMatrix(m_K, numPatches);
                S = m_D.transAmult(X, S);

                //create a variable to keep track of the maximum value in each column of S
                double max;

                //for each column in matrix S...
                for (int c = 0; c < S.numColumns(); c++) {
                    //set the max to be the absolute value of the first value in the current column
                    max = Math.abs(S.get(0, c));

                    //for each row in the current column of matrix S...
                    for (int r = 0; r < S.numRows(); r++) {
                        //if the current absolute value is greater than the current max...
                        if (Math.abs(S.get(r, c)) > max) {
                            //set the max to this absolute value
                            max = Math.abs(S.get(r, c));
                        } else {
                            //set the value to 0
                            S.set(r, c, 0);
                        }
                    }

                    //for each row in the current column in S...
                    for (int r = 0; r < S.numRows(); r++) {
                        //if the current absolute value is not the max...
                        if (Math.abs(S.get(r, c)) != max) {
                            //set the value to 0
                            S.set(r, c, 0);
                        }
                    }
                }

                //if the current SSE is equal to the previous SSE...
                if(prevSSE == calculateSumOfSquaredErrors(X, S)) {
                    //break from the while loop
                    break;
                } else {
                    //set the previous SSE to the current SSE
                    prevSSE = calculateSumOfSquaredErrors(X, S);
                }

                //update m_D by multipling the transpose of X with S and then adding m_D
                m_D = X.transBmultAdd(S, m_D);
                //normalise the columns of m_D
                normalizeD();
            }
        }

        //create an empty Instances object
        Instances allInstances = determineOutputFormat(data);

        //create a variable to store the number of patches extracted from each image
        int NumPatchesPerImage;
        //create a variable to store the height and width of the feature maps
        int featureMapSize;
        //create a variable to store the number of values in each feature map after pooling
        int numPooledPatches;
        //create a variable to store all the pooled feature maps for an image
        double[] pooledFeatureMaps;

        //create a matrix to store all the normalised patches from an image
        Matrix P;
        //create a matrix to store all the feature maps for an image
        Matrix F;

        //for each image
        for (int image = 0; image < data.numInstances(); image++) {

            //create variable to keep track of patch number
            int patchIndex = 0;

            //extract image path
            String fileName = data.instance(image).stringValue(0);
            //extract image class value
            double imageClass = data.instance(image).classValue();

            //declare an image object
            BufferedImage img = null;

            try {
                //intialise image object to the given image path
                img = ImageIO.read(new File(fileName));

                //calculate the number of patches to extract from the image
                NumPatchesPerImage = (1 + ((img.getWidth() - m_cropSize) / m_stride)) * (1 + ((img.getWidth() - m_cropSize) / m_stride));

                //intialise P to an empty matrix to store all patches
                P = new DenseMatrix(NumPatchesPerImage, numPatchValues);

                //for each patch
                for(int row = 0; row <= img.getHeight() - m_cropSize; row += m_stride) {
                    for(int col = 0; col <= img.getWidth() - m_cropSize; col += m_stride) {

                        //get image patch
                        BufferedImage patch = img.getSubimage(row, col, m_cropSize, m_cropSize);

                        //normalise patch vector
                        int index = 0;
                        Vector vec = new DenseVector(numPatchValues);
                        for (int j = 0; j < m_cropSize; j++) {
                            for (int k = 0; k < m_cropSize; k++) {
                                int rgb = patch.getRGB(k,j);
                                int r = (rgb >> 16) & 0xFF;
                                int g = (rgb >> 8) & 0xFF;
                                int b = (rgb & 0xFF);
                                vec.set(index, r);
                                vec.set(numPatchPixels + index, g);
                                vec.set(2 * numPatchPixels + index, b);
                                index++;
                            }
                        }
                        Vector centeredVec = vec.add(-vec.dot(oneOverNumPatchValues), allOnesNumPatchValues);
                        double norm = centeredVec.norm(Vector.Norm.Two);
                        Vector normalizedVec = centeredVec.scale(1.0 / Math.sqrt((norm * norm) / vec.size() + 10));

                        //store normalised patch vector as a new row in P
                        for (int c = 0; c < normalizedVec.size(); c++) {
                            P.set(patchIndex, c, normalizedVec.get(c));
                        }
                        //increment patch number
                        patchIndex++;
                    }
                }

                //intialise F to an empty matrix to store raw feature maps for each filter
                F = new DenseMatrix(NumPatchesPerImage, m_K);

                //generate values for F by mutlipling P with m_D
                F = P.mult(m_D, F);

                //for each element in F set all negative values to 0 (ACTIVATION FUNCTION)
                for(int row = 0; row < F.numRows(); row++) {
                    for(int col = 0; col < F.numColumns(); col++) {
                        if(F.get(row, col) < 0) {
                            F.set(row, col, 0);
                        }
                    }
                }

                //calculate the height and width of the feature maps
                featureMapSize = (int)Math.sqrt(NumPatchesPerImage);
                //calculate the number of values in each feature map after pooling
                numPooledPatches = NumPatchesPerImage/(m_poolSize*m_poolSize);
                //create an empty array to store all pooled feature maps and the class value of the image
                pooledFeatureMaps = new double[m_K * numPooledPatches + 1];

                //create a variable to keep track of which element of the "pooledFeatureMaps" array we are at
                int index = 0;
                //create a vatriable to keep track of sum of the values in each pooling patch
                double sum;

                //for each feature map
                for(int feature = 0; feature < F.numColumns(); feature++) {

                    //for each pooling patch
                    for (int row = 0; row <= featureMapSize - m_poolSize; row += m_poolSize) {
                        for (int col = 0; col <= featureMapSize - m_poolSize; col += m_poolSize) {

                            //intialise sum to 0
                            sum = 0;

                            //sum up each value in the patch
                            for (int i = 0; i < m_poolSize; i++) {
                                for (int j = 0; j < m_poolSize; j++) {
                                    sum += F.get((row + i) * featureMapSize + (col + j), feature);
                                }
                            }

                            //add the average value of the patch to the pooled feature map array
                            pooledFeatureMaps[index] = sum/(m_poolSize*m_poolSize);
                            //increment index value
                            index++;
                        }
                    }
                }

                //add the image class to the last element of the "pooledFeatureMaps" array
                pooledFeatureMaps[index] = imageClass;

                //create a new Instance object from the "pooledFeatureMaps" array and add it to the Instances object
                allInstances.add(new DenseInstance(1, pooledFeatureMaps));

            } catch (IOException e) {
                System.err.println("File " + fileName + " could not be read");
            }

        }

        //return the Instnaces object
        return allInstances;
    }

    /**
     * The method that normalises all columns in m_D to length 1
     */
    protected void normalizeD() {

        //for each column in m_D...
        for(int i =0; i < m_D.numColumns(); i++) {
            //get the length of the column
            double length = Matrices.getColumn(m_D, i).norm(Vector.Norm.Two);
            //for each value in the current column...
            for (int j = 0; j < m_D.numRows(); j++) {
                //divide the current value by the length of the current column
                m_D.set(j, i, m_D.get(j, i) / length);
            }
        }
    }

    /**
     * A utility method for calculating the sum of squared errors during k-means iterations
     * based on the X matrix, the current S matrix, and the current dictionary stored in
     * a member variable. Useful for checking whether the error decreases monotonically,
     * which it should if k-means has been implemented correctly.
     *
     * @param X the X matrix
     * @param S the S matrix
     * @return the sum of squared errors
     */
    protected double calculateSumOfSquaredErrors(Matrix X, Matrix S) {

        double SSE = 0;
        for (int i = 0; i < X.numColumns(); i++) {
            Vector projected = m_D.mult(Matrices.getColumn(S, i), new DenseVector(X.numRows()));
            double n = Matrices.getColumn(X, i).add(-1.0, projected).norm(Vector.Norm.Two);
            SSE += n * n;
        }
        return SSE;
    }

    /**
     * The info shown in the GUI.
     * @return the info describing the filter.
     */
    public String globalInfo() {
        return "This filter performs feature extraction from images using the spherical k-means algorithm.";
    }

    /**
     * The capabilities of this filter.
     * @return the capabilities
     */
    public Capabilities getCapabilities() {
        Capabilities result = super.getCapabilities();
        result.enable(Capabilities.Capability.STRING_ATTRIBUTES);
        result.enableAllClasses();
        result.enable(Capabilities.Capability.NO_CLASS); // Filter doesn't require class to be set
        result.enable(Capabilities.Capability.MISSING_CLASS_VALUES);
        return result;
    }

    /**
     * We need to have access to the full input format so that we can read the images.
     *
     * @return true
     */
    public boolean allowAccessToFullInputFormat() {
        return true;
    }

    @OptionMetadata(
            displayName = "Seed for random number generation",
            description = "The seed value used by the random number generator.",
            displayOrder = 1,
            commandLineParamName = "S",
            commandLineParamSynopsis = "-S")
    public int getSeed() {
        return m_seed;
    }
    public void setSeed(int seed) {
        this.m_seed = seed;
    }

    @OptionMetadata(
            displayName = "Patch size to use (value X means X x X patches will be used)",
            description = "The patch size to use (value X means X x X patches will be used).",
            displayOrder = 2,
            commandLineParamName = "size",
            commandLineParamSynopsis = "-size")
    public int getCropSize() {
        return m_cropSize;
    }
    public void setCropSize(int cropSize) {
        this.m_cropSize = cropSize;
    }

    @OptionMetadata(
            displayName = "Number of patches per image",
            description = "The number of patches to be extracted per image.",
            displayOrder = 3,
            commandLineParamName = "numPatches",
            commandLineParamSynopsis = "-numPatches")
    public int getNumPatchesPerImage() {
        return m_numPatchesPerImage;
    }
    public void setNumPatchesPerImage(int numPatchesPerImage) {
        this.m_numPatchesPerImage = numPatchesPerImage;
    }

    @OptionMetadata(
            displayName = "Number of clusters",
            description = "The number of clusters/filters/dictionary atoms to learn.",
            displayOrder = 4,
            commandLineParamName = "K",
            commandLineParamSynopsis = "-K")
    public int getK() {
        return m_K;
    }
    public void setK(int K) {
        this.m_K = K;
    }

    @OptionMetadata(
            displayName = "Stride",
            description = "The stride to use when filters are applied to an image (both directions).",
            displayOrder = 5,
            commandLineParamName = "stride",
            commandLineParamSynopsis = "-stride")
    public int getStride() {
        return m_stride;
    }
    public void setStride(int stride) {
        this.m_stride = stride;
    }

    @OptionMetadata(
            displayName = "Pool size",
            description = "The size of the pool to use when creating features (both directions).",
            displayOrder = 6,
            commandLineParamName = "pool",
            commandLineParamSynopsis = "-pool")
    public int getPoolSize() {
        return m_poolSize;
    }
    public void setPoolSize(int pool) {
        this.m_poolSize = pool;
    }

    /**
     * The main method used for running this filter from the command-line interface.
     *
     * @param options the command-line options
     */
    public static void main(String[] options) {
        runFilter(new KMeansImageFilter(), options);
    }
}
